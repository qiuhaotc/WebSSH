@page "/Shell/{UniqueId:guid}"
@inject HttpClient Http
@inject NavigationManager NavManager
@inject IJSRuntime JSRuntime;
@using Microsoft.AspNetCore.SignalR.Client
@implements IAsyncDisposable

<h3>Shell</h3>

<div class="row">
    <div class="col-md-12">
        <div id="ShellOutput" style="width:100%;height:70vh; background:#000; color:#fff;"></div>
        <div class="mt-2 small text-muted">Connection: @connectionStatus
            <button class="btn btn-sm btn-secondary ms-2" @onclick="Clear">Clear</button>
        </div>
    </div>
</div>

@code{

    [Parameter]
    public Guid UniqueId { get; set; }

    HubConnection hubConnection;
    string connectionStatus = "Initializing";
    DotNetObjectReference<RemoteShell> dotNetRef;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            try
            {
                dotNetRef = DotNetObjectReference.Create(this);
                await JSRuntime.InvokeVoidAsync("websshTerm.init", "ShellOutput", dotNetRef);
                currentOutputIndex = 0;

                hubConnection = new HubConnectionBuilder()
                    .WithUrl(NavManager.ToAbsoluteUri("/shellHub"))
                    .WithAutomaticReconnect()
                    .Build();

                hubConnection.On<string>("ShellOutput", (output) =>
                {
                    _ = JSRuntime.InvokeVoidAsync("websshTerm.write", output);
                });

                hubConnection.Reconnecting += async error =>
                {
                    connectionStatus = "Reconnecting";
                    _ = JSRuntime.InvokeVoidAsync("websshTerm.write", $"\r\n[client] Connection lost, reconnecting... {error?.Message}\r\n");
                    await InvokeAsync(StateHasChanged);
                };

                hubConnection.Reconnected += async id =>
                {
                    connectionStatus = "Connected";
                    _ = JSRuntime.InvokeVoidAsync("websshTerm.write", "\r\n[client] Reconnected.\r\n");
                    await InvokeAsync(StateHasChanged);
                };

                hubConnection.Closed += async error =>
                {
                    connectionStatus = "Disconnected";
                    _ = JSRuntime.InvokeVoidAsync("websshTerm.write", $"\r\n[client] Connection closed: {error?.Message}\r\n");
                    await InvokeAsync(StateHasChanged);
                };

                await hubConnection.StartAsync();
                await hubConnection.InvokeAsync("JoinShell", UniqueId);
                connectionStatus = "Connected";
                await InvokeAsync(StateHasChanged);
            }
            catch (Exception ex)
            {
                await JSRuntime.InvokeVoidAsync("websshTerm.write", $"\r\n[client] {ex.Message}\r\n");
                connectionStatus = "Error";
                await InvokeAsync(StateHasChanged);
            }
        }

        await base.OnAfterRenderAsync(firstRender);
    }

    protected override async Task OnInitializedAsync()
    {
        await base.OnInitializedAsync();
    }

    async void Clear()
    {
        await JSRuntime.InvokeVoidAsync("websshTerm.clear");
    }

    int currentOutputIndex;

    // Legacy StaticUtils console buffering removed for xterm direct streaming.

    [JSInvokable]
    public Task SendInput(string data)
    {
        if (hubConnection?.State == HubConnectionState.Connected)
        {
            return hubConnection.InvokeAsync("SendInput", UniqueId, data);
        }
        return Task.CompletedTask;
    }

    public async ValueTask DisposeAsync()
    {
        if (hubConnection != null)
        {
            try
            {
                await hubConnection.DisposeAsync();
            }
            catch { }
        }
        dotNetRef?.Dispose();
    }
}