@page "/Shell/{UniqueId:guid}"
@inject HttpClient Http
@inject NavigationManager NavManager
@inject IJSRuntime JSRuntime;
@using Microsoft.AspNetCore.SignalR.Client
@using Microsoft.AspNetCore.Components.Forms
@using System.Net.Http.Headers
@using System.IO
@using System.Text.Json
@implements IAsyncDisposable

<h3>Shell</h3>

<div class="container-fluid">
    <!-- Tab Navigation -->
    <ul class="nav nav-tabs" id="shellTabs" role="tablist">
        <li class="nav-item" role="presentation">
            <button class="nav-link @(activeTab == "console" ? "active" : "")" 
                    @onclick="@(() => SwitchTab("console"))" 
                    type="button" role="tab">
                Shell Console
            </button>
        </li>
        <li class="nav-item" role="presentation">
            <button class="nav-link @(activeTab == "upload" ? "active" : "")" 
                    @onclick="@(() => SwitchTab("upload"))" 
                    type="button" role="tab">
                Upload Files
            </button>
        </li>
        <li class="nav-item" role="presentation">
            <button class="nav-link @(activeTab == "download" ? "active" : "")" 
                    @onclick="@(() => SwitchTab("download"))" 
                    type="button" role="tab">
                Download Files
            </button>
        </li>
    </ul>

    <!-- Tab Content -->
    <div class="tab-content mt-3">
        <!-- Shell Console Tab -->
        <div class="tab-pane fade @(activeTab == "console" ? "show active" : "")">
            <div class="row">
                <div class="col-md-12">
                    <div id="ShellOutput" style="width:100%;height:60vh; background:#000; color:#fff;"></div>
                    <div class="mt-2 small text-muted">Connection: @connectionStatus
                        <button class="btn btn-sm btn-secondary ms-2" @onclick="Clear">Clear</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Upload Files Tab -->
        <div class="tab-pane fade @(activeTab == "upload" ? "show active" : "")">
            <div class="row">
                <div class="col-md-12">
                    <div class="card">
                        <div class="card-header">
                            <h5>Upload Files to Remote Server</h5>
                            <small class="text-muted">
                                Limits: Max 3 files per upload, 10MB per file, 20 files per hour
                            </small>
                        </div>
                        <div class="card-body">
                            <div class="form-group mb-3">
                                <label for="remotePath">Remote Path:</label>
                                <input type="text" id="remotePath" class="form-control" @bind="remotePath" placeholder="/"/>
                                <small class="form-text text-muted">Specify the remote directory path (e.g., / for root directory, /home/user for user directory)</small>
                            </div>
                            <div class="form-group mb-3">
                                <label for="fileInput">Select Files:</label>
                                <InputFile id="fileInput" OnChange="OnFileSelected" multiple class="form-control" accept="*/*" />
                                <small class="form-text text-muted">You can select up to 3 files to upload (max 10MB each)</small>
                            </div>
                            @if (selectedFiles != null && selectedFiles.Count > 0)
                            {
                                <div class="mb-3">
                                    <h6>Selected Files (@selectedFiles.Count):</h6>
                                    <ul class="list-group">
                                        @foreach (var file in selectedFiles)
                                        {
                                            <li class="list-group-item d-flex justify-content-between">
                                                <span>@file.Name</span>
                                                <small>@FormatFileSize(file.Size)</small>
                                            </li>
                                        }
                                    </ul>
                                </div>
                                <button class="btn btn-primary" @onclick="UploadFiles" disabled="@isUploading">
                                    @if (isUploading)
                                    {
                                        <span class="spinner-border spinner-border-sm" role="status"></span>
                                        <span>Uploading...</span>
                                    }
                                    else
                                    {
                                        <span>Upload Files</span>
                                    }
                                </button>
                            }
                            @if (!string.IsNullOrEmpty(uploadStatus))
                            {
                                <div class="alert @(uploadStatus.Contains("Error") || uploadStatus.Contains("failed") ? "alert-danger" : "alert-info") mt-3" style="white-space: pre-line;">
                                    @uploadStatus
                                </div>
                            }
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Download Files Tab -->
        <div class="tab-pane fade @(activeTab == "download" ? "show active" : "")">
            <div class="row">
                <div class="col-md-12">
                    <div class="card">
                        <div class="card-header">
                            <h5>Download Files from Remote Server</h5>
                            <small class="text-muted">
                                Limits: Max 3 files per download, 50MB total size, 20 downloads per hour
                            </small>
                        </div>
                        <div class="card-body">
                            <div class="form-group mb-3">
                                <label for="browsePath">Browse Path:</label>
                                <div class="input-group">
                                    <input type="text" id="browsePath" class="form-control" @bind="browsePath" placeholder="/" />
                                    <button class="btn btn-outline-secondary" @onclick="BrowseFiles" disabled="@isLoadingFiles">
                                        @if (isLoadingFiles)
                                        {
                                            <span class="spinner-border spinner-border-sm" role="status"></span>
                                        }
                                        else
                                        {
                                            <span>Browse</span>
                                        }
                                    </button>
                                </div>
                                <small class="form-text text-muted">Enter the path to browse remote files (e.g., / for root directory)</small>
                            </div>

                            @if (remoteFiles != null && remoteFiles.Count > 0)
                            {
                                <div class="mb-3">
                                    <h6>Select Files to Download:</h6>
                                    <div class="table-responsive" style="max-height: 400px; overflow-y: auto; border: 1px solid #dee2e6; border-radius: 0.375rem;">
                                        <table class="table table-sm table-hover mb-0">
                                            <thead class="table-light sticky-top">
                                                <tr>
                                                    <th width="60" class="text-center">Select</th>
                                                    <th style="min-width: 200px;">Name</th>
                                                    <th width="100" class="text-end">Size</th>
                                                    <th width="160" class="text-center">Modified</th>
                                                </tr>
                                            </thead>
                                            <tbody>
                                                @foreach (var file in remoteFiles)
                                                {
                                                    <tr class="@(file.IsDirectory ? "table-secondary" : "")" @ondblclick="@(() => { if (file.IsDirectory && file.Name != "..") NavigateToDirectory(file.FullPath); })">
                                                        <td class="text-center">
                                                            @if (!file.IsDirectory)
                                                            {
                                                                <input type="checkbox" class="form-check-input" 
                                                                       @onchange="@((e) => ToggleFileSelection(file, (bool)e.Value))" 
                                                                       checked="@selectedFilesForDownload.Contains(file.FullPath)" />
                                                            }
                                                            else if (file.Name != "..")
                                                            {
                                                                <button class="btn btn-sm btn-link p-0" 
                                                                        @onclick="@(() => NavigateToDirectory(file.FullPath))">
                                                                    📁
                                                                </button>
                                                            }
                                                            else
                                                            {
                                                                <button class="btn btn-sm btn-link p-0" 
                                                                        @onclick="@(() => NavigateToParentDirectory())">
                                                                    ⬆️
                                                                </button>
                                                            }
                                                        </td>
                                                        <td>
                                                            <span class="@(file.IsDirectory ? "fw-bold" : "")" style="word-break: break-all; font-family: 'Courier New', monospace;">
                                                                @(file.IsDirectory ? "📁 " + file.Name : file.Name)
                                                            </span>
                                                        </td>
                                                        <td class="text-end">@(file.IsDirectory ? "-" : FormatFileSize(file.Size))</td>
                                                        <td class="text-center" style="font-family: 'Courier New', monospace;">@file.LastModified.ToString("yyyy-MM-dd HH:mm:ss")</td>
                                                    </tr>
                                                }
                                            </tbody>
                                        </table>
                                    </div>
                                </div>
                            }

                            @if (selectedFilesForDownload.Count > 0)
                            {
                                <div class="mb-3">
                                    <h6>Selected Files (@selectedFilesForDownload.Count):</h6>
                                    <ul class="list-group">
                                        @foreach (var filePath in selectedFilesForDownload)
                                        {
                                            <li class="list-group-item d-flex justify-content-between">
                                                <span>@Path.GetFileName(filePath)</span>
                                                <button class="btn btn-sm btn-outline-danger" @onclick="@(() => RemoveFileSelection(filePath))">×</button>
                                            </li>
                                        }
                                    </ul>
                                </div>
                                <button class="btn btn-success" @onclick="DownloadFiles" disabled="@isDownloading">
                                    @if (isDownloading)
                                    {
                                        <span class="spinner-border spinner-border-sm" role="status"></span>
                                        <span>Downloading...</span>
                                    }
                                    else
                                    {
                                        <span>Download Selected Files</span>
                                    }
                                </button>
                            }

                            @if (!string.IsNullOrEmpty(downloadStatus))
                            {
                                <div class="alert @(downloadStatus.Contains("Error") || downloadStatus.Contains("failed") ? "alert-danger" : "alert-info") mt-3" style="white-space: pre-line;">
                                    @downloadStatus
                                </div>
                            }
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

@code{

    [Parameter]
    public Guid UniqueId { get; set; }

    HubConnection hubConnection;
    string connectionStatus = "Initializing";
    DotNetObjectReference<RemoteShell> dotNetRef;

    // Tab management
    private string activeTab = "console";

    // File upload properties
    private string remotePath = "/";
    private List<IBrowserFile> selectedFiles = new();
    private bool isUploading = false;
    private string uploadStatus = "";

    // File download properties
    private string browsePath = "/";
    private List<RemoteFileInfo> remoteFiles = new();
    private List<string> selectedFilesForDownload = new();
    private bool isDownloading = false;
    private bool isLoadingFiles = false;
    private string downloadStatus = "";

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            try
            {
                dotNetRef = DotNetObjectReference.Create(this);
                await JSRuntime.InvokeVoidAsync("websshTerm.init", "ShellOutput", dotNetRef);

                hubConnection = new HubConnectionBuilder()
                    .WithUrl(NavManager.ToAbsoluteUri("/shellHub"))
                    .WithAutomaticReconnect()
                    .Build();

                hubConnection.On<string>("ShellOutput", (output) =>
                {
                    _ = JSRuntime.InvokeVoidAsync("websshTerm.write", output);
                });

                hubConnection.On<string>("FileUploadStatus", (status) =>
                {
                    _ = InvokeAsync(() =>
                    {
                        uploadStatus = status;
                        StateHasChanged();
                    });
                });

                hubConnection.On<string>("FileDownloadStatus", (status) =>
                {
                    _ = InvokeAsync(() =>
                    {
                        downloadStatus = status;
                        StateHasChanged();
                    });
                });

                hubConnection.Reconnecting += async error =>
                {
                    connectionStatus = "Reconnecting";
                    _ = JSRuntime.InvokeVoidAsync("websshTerm.write", $"\r\n[client] Connection lost, reconnecting... {error?.Message}\r\n");
                    await InvokeAsync(StateHasChanged);
                };

                hubConnection.Reconnected += async id =>
                {
                    connectionStatus = "Connected";
                    _ = JSRuntime.InvokeVoidAsync("websshTerm.write", "\r\n[client] Reconnected.\r\n");
                    await InvokeAsync(StateHasChanged);
                };

                hubConnection.Closed += async error =>
                {
                    connectionStatus = "Disconnected";
                    _ = JSRuntime.InvokeVoidAsync("websshTerm.write", $"\r\n[client] Connection closed: {error?.Message}\r\n");
                    await InvokeAsync(StateHasChanged);
                };

                await hubConnection.StartAsync();
                await hubConnection.InvokeAsync("JoinShell", UniqueId);
                connectionStatus = "Connected";
                await InvokeAsync(StateHasChanged);
            }
            catch (Exception ex)
            {
                await JSRuntime.InvokeVoidAsync("websshTerm.write", $"\r\n[client] {ex.Message}\r\n");
                connectionStatus = "Error";
                await InvokeAsync(StateHasChanged);
            }
        }

        await base.OnAfterRenderAsync(firstRender);
    }

    protected override async Task OnInitializedAsync()
    {
        await base.OnInitializedAsync();
    }

    async void Clear()
    {
        await JSRuntime.InvokeVoidAsync("websshTerm.clear");
    }

    void SwitchTab(string tab)
    {
        activeTab = tab;
        StateHasChanged();
    }

    private void OnFileSelected(InputFileChangeEventArgs e)
    {
        selectedFiles = e.GetMultipleFiles(3).ToList(); // Limit to 3 files as per configuration
        
        // Client-side validation
        var maxSizeBytes = 10 * 1024 * 1024; // 10MB
        var oversizedFiles = selectedFiles.Where(f => f.Size > maxSizeBytes).ToList();
        
        if (oversizedFiles.Any())
        {
            uploadStatus = $"Error: The following files are too large (max 10MB): {string.Join(", ", oversizedFiles.Select(f => f.Name))}";
            selectedFiles = selectedFiles.Except(oversizedFiles).ToList();
        }
        else if (selectedFiles.Count > 3)
        {
            uploadStatus = "Error: Too many files selected. Maximum 3 files allowed per upload.";
            selectedFiles = selectedFiles.Take(3).ToList();
        }
        else
        {
            uploadStatus = "";
        }
        
        StateHasChanged();
    }

    private async Task UploadFiles()
    {
        if (selectedFiles == null || selectedFiles.Count == 0)
            return;

        // Client-side validation before upload
        if (selectedFiles.Count > 3)
        {
            uploadStatus = "Error: Maximum 3 files allowed per upload.";
            return;
        }

        var maxSizeBytes = 10 * 1024 * 1024; // 10MB
        var oversizedFiles = selectedFiles.Where(f => f.Size > maxSizeBytes).ToList();
        if (oversizedFiles.Any())
        {
            uploadStatus = $"Error: Files too large (max 10MB): {string.Join(", ", oversizedFiles.Select(f => f.Name))}";
            return;
        }

        isUploading = true;
        uploadStatus = "Preparing upload...";
        StateHasChanged();

        try
        {
            await hubConnection.InvokeAsync("NotifyFileUploadStart", UniqueId, selectedFiles.Count);

            using var content = new MultipartFormDataContent();
            
            foreach (var file in selectedFiles)
            {
                var streamContent = new StreamContent(file.OpenReadStream(maxAllowedSize: 10 * 1024 * 1024)); // 10MB limit
                // Handle ContentType safely for all file types including MSI
                var contentType = !string.IsNullOrWhiteSpace(file.ContentType) ? file.ContentType : "application/octet-stream";
                streamContent.Headers.ContentType = new MediaTypeHeaderValue(contentType);
                content.Add(streamContent, "files", file.Name);
            }

            content.Add(new StringContent(remotePath), "remotePath");

            var response = await Http.PostAsync($"/api/FileUpload/UploadFiles?uniqueId={UniqueId}", content);
            
            if (response.IsSuccessStatusCode)
            {
                var result = await response.Content.ReadFromJsonAsync<ServerResponse<FileUploadResult>>();
                if (result?.StausResult == StausResult.Successful && result.Response != null)
                {
                    uploadStatus = $"Upload completed: {result.Response.SuccessfulUploads}/{result.Response.TotalFiles} files uploaded successfully";
                    
                    // Show individual file errors if any
                    var failedFiles = result.Response.UploadedFiles.Where(f => !f.Success).ToList();
                    if (failedFiles.Any())
                    {
                        uploadStatus += $"\n\nErrors:\n{string.Join("\n", failedFiles.Select(f => $"• {f.FileName}: {f.ErrorMessage}"))}";
                    }
                    
                    // Clear selected files on success
                    if (result.Response.SuccessfulUploads > 0)
                    {
                        selectedFiles.Clear();
                    }
                }
                else
                {
                    uploadStatus = $"Error: {result?.ExtraMessage ?? "Unknown error occurred"}";
                }
            }
            else
            {
                var errorContent = await response.Content.ReadAsStringAsync();
                uploadStatus = $"Error: HTTP {response.StatusCode} - {errorContent}";
            }
        }
        catch (Exception ex)
        {
            uploadStatus = $"Error: {ex.Message}";
        }
        finally
        {
            isUploading = false;
            StateHasChanged();
        }
    }

    private string FormatFileSize(long bytes)
    {
        string[] sizes = { "B", "KB", "MB", "GB" };
        double len = bytes;
        int order = 0;
        while (len >= 1024 && order < sizes.Length - 1)
        {
            order++;
            len = len / 1024;
        }
        return $"{len:0.##} {sizes[order]}";
    }

    // Download functionality methods
    private async Task BrowseFiles()
    {
        isLoadingFiles = true;
        downloadStatus = "";
        StateHasChanged();

        try
        {
            var response = await Http.GetAsync($"/api/FileDownload/ListFiles?uniqueId={UniqueId}&path={Uri.EscapeDataString(browsePath)}");
            
            if (response.IsSuccessStatusCode)
            {
                var result = await response.Content.ReadFromJsonAsync<ServerResponse<List<RemoteFileInfo>>>();
                if (result?.StausResult == StausResult.Successful && result.Response != null)
                {
                    remoteFiles = result.Response;
                    downloadStatus = $"Found {remoteFiles.Count} items";
                }
                else
                {
                    downloadStatus = $"Error: {result?.ExtraMessage ?? "Unknown error"}";
                    remoteFiles.Clear();
                }
            }
            else
            {
                var errorContent = await response.Content.ReadAsStringAsync();
                downloadStatus = $"Error: HTTP {response.StatusCode} - {errorContent}";
                remoteFiles.Clear();
            }
        }
        catch (Exception ex)
        {
            downloadStatus = $"Error browsing files: {ex.Message}";
            remoteFiles.Clear();
        }
        finally
        {
            isLoadingFiles = false;
            StateHasChanged();
        }
    }

    private void ToggleFileSelection(RemoteFileInfo file, bool selected)
    {
        if (selected)
        {
            if (!selectedFilesForDownload.Contains(file.FullPath))
            {
                if (selectedFilesForDownload.Count < 3) // Match the MaxFilesPerDownload limit
                {
                    selectedFilesForDownload.Add(file.FullPath);
                }
                else
                {
                    downloadStatus = "Error: Maximum 3 files allowed per download.";
                }
            }
        }
        else
        {
            selectedFilesForDownload.Remove(file.FullPath);
        }
        StateHasChanged();
    }

    private void RemoveFileSelection(string filePath)
    {
        selectedFilesForDownload.Remove(filePath);
        StateHasChanged();
    }

    private async Task NavigateToDirectory(string path)
    {
        browsePath = path.EndsWith('/') ? path : path + "/";
        await BrowseFiles();
    }

    private async Task NavigateToParentDirectory()
    {
        if (browsePath != "/")
        {
            var parentPath = Path.GetDirectoryName(browsePath.TrimEnd('/'));
            browsePath = string.IsNullOrEmpty(parentPath) ? "/" : parentPath.Replace('\\', '/');
            if (!browsePath.EndsWith('/'))
                browsePath += "/";
        }
        await BrowseFiles();
    }

    private async Task DownloadFiles()
    {
        if (selectedFilesForDownload.Count == 0)
            return;

        isDownloading = true;
        downloadStatus = "Preparing download...";
        StateHasChanged();

        try
        {
            await hubConnection.InvokeAsync("NotifyFileDownloadStart", UniqueId, selectedFilesForDownload.Count);

            var request = new FileDownloadRequest
            {
                FilePaths = selectedFilesForDownload.ToList()
            };

            var response = await Http.PostAsJsonAsync($"/api/FileDownload/DownloadFiles?uniqueId={UniqueId}", request);
            
            if (response.IsSuccessStatusCode)
            {
                var contentDisposition = response.Headers.GetValues("Content-Disposition").FirstOrDefault();
                var fileName = "download.zip";
                
                if (contentDisposition != null)
                {
                    var fileNameMatch = System.Text.RegularExpressions.Regex.Match(contentDisposition, @"filename=""([^""]+)""");
                    if (fileNameMatch.Success)
                    {
                        fileName = fileNameMatch.Groups[1].Value;
                    }
                }

                var fileBytes = await response.Content.ReadAsByteArrayAsync();
                await JSRuntime.InvokeVoidAsync("downloadFile", fileName, Convert.ToBase64String(fileBytes));
                
                downloadStatus = "Download completed successfully!";
                selectedFilesForDownload.Clear();
            }
            else
            {
                var errorContent = await response.Content.ReadAsStringAsync();
                downloadStatus = $"Error: HTTP {response.StatusCode} - {errorContent}";
            }
        }
        catch (Exception ex)
        {
            downloadStatus = $"Error: {ex.Message}";
        }
        finally
        {
            isDownloading = false;
            StateHasChanged();
        }
    }

    // Legacy StaticUtils console buffering removed for xterm direct streaming.

    [JSInvokable]
    public Task SendInput(string data)
    {
        if (hubConnection?.State == HubConnectionState.Connected)
        {
            return hubConnection.InvokeAsync("SendInput", UniqueId, data);
        }
        return Task.CompletedTask;
    }

    public async ValueTask DisposeAsync()
    {
        if (hubConnection != null)
        {
            try
            {
                await hubConnection.DisposeAsync();
            }
            catch { }
        }
        dotNetRef?.Dispose();
    }
}