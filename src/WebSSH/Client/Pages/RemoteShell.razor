@page "/Shell/{UniqueId:guid}"
@inject HttpClient Http
@inject NavigationManager NavManager
@inject IJSRuntime JSRuntime;
@using Microsoft.AspNetCore.SignalR.Client
@implements IAsyncDisposable

<h3>Shell</h3>

<div class="row">
    <div class="col-md-12">
        <div id="ShellOutput"></div>
        <div class="mt-2 small text-muted">Connection: @connectionStatus</div>
    </div>
    <div class="form-group col-md-2">
        <label for="CommandMode">Command Mode</label>
        <select class="form-control" id="CommandMode" @bind="@CommandMode">
            <option value="0">Single Line</option>
            <option value="1">Multi Lines</option>
        </select>
    </div>
    <div class="form-group  col-md-10">
        <label for="CommandText">Command Content</label>
        @if (CommandMode == 0)
        {
            <input type="text" class="form-control" autocomplete="off" id="CommandText" @onkeydown="@OnCommandKeydown" @bind-value="@Command" @bind-value:event="oninput">
        }
        else
        {
            <textarea id="CommandText" class="form-control" @bind="@Command" @bind:event="oninput"></textarea>
        }
    </div>
    <div class="form-group  col-md-12">
        <button type="button" class="btn btn-primary" @onclick="@RunCommand">Run Command</button>
        <button type="button" class="btn btn-danger" @onclick="@Clear">Clear</button>
    </div>
</div>

@code{

    [Parameter]
    public Guid UniqueId { get; set; }

    public int CommandMode { get; set; }

    HubConnection hubConnection;
    string connectionStatus = "Initializing";
    public string Command { get; set; } = string.Empty;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            try
            {
                await JSRuntime.InvokeAsync<object>("StartTerm", "ShellOutput");
                WriteToConsole();
                currentCommandLine = StaticUtils.InitCurrentCommandLine(UniqueId);

                hubConnection = new HubConnectionBuilder()
                    .WithUrl(NavManager.ToAbsoluteUri("/shellHub"))
                    .WithAutomaticReconnect()
                    .Build();

                hubConnection.On<string>("ShellOutput", async (output) =>
                {
                    await WriteToConsole(output, false);
                });

                hubConnection.Reconnecting += error =>
                {
                    connectionStatus = "Reconnecting";
                    _ = WriteToConsole($"Connection lost, reconnecting... {error?.Message}");
                    InvokeAsync(StateHasChanged);
                    return Task.CompletedTask;
                };

                hubConnection.Reconnected += id =>
                {
                    connectionStatus = "Connected";
                    _ = WriteToConsole("Reconnected");
                    InvokeAsync(StateHasChanged);
                    return Task.CompletedTask;
                };

                hubConnection.Closed += error =>
                {
                    connectionStatus = "Disconnected";
                    _ = WriteToConsole($"Connection closed: {error?.Message}");
                    InvokeAsync(StateHasChanged);
                    return Task.CompletedTask;
                };

                await hubConnection.StartAsync();
                await hubConnection.InvokeAsync("JoinShell", UniqueId);
                connectionStatus = "Connected";
            }
            catch (Exception ex)
            {
                await WriteToConsole(ex.Message);
                connectionStatus = "Error";
            }
        }

        await base.OnAfterRenderAsync(firstRender);
    }

    protected override async Task OnInitializedAsync()
    {
        await base.OnInitializedAsync();
    }

    bool IsRunningCommand { get; set; }

    async void RunCommand()
    {
        if (IsRunningCommand)
        {
            await WriteToConsole("Is running command, please wait for pre-command finished");
            return;
        }

        IsRunningCommand = true;

        try
        {
            StaticUtils.RecordCommands(UniqueId, Command, ref currentCommandLine);
            var trimmed = Command?.TrimEnd();
            if (!string.IsNullOrWhiteSpace(trimmed))
            {
                // Local echo (optional)
                await WriteToConsole($"> {trimmed}");
            }

            if (hubConnection == null || hubConnection.State != HubConnectionState.Connected)
            {
                await WriteToConsole("Hub not connected, cannot send command");
            }
            else
            {
                await hubConnection.InvokeAsync("RunCommand", UniqueId, Command);
            }
        }
        catch (Exception ex)
        {
            await WriteToConsole(ex.Message);
        }

        IsRunningCommand = false;
        Command = string.Empty;
        StateHasChanged();
    }

    async void Clear()
    {
        Command = string.Empty;
        StaticUtils.Clear(UniqueId);
        await JSRuntime.InvokeAsync<object>("ClearTerm");
        currentOutputIndex = 0;
        currentCommandLine = 1;
    }

    int currentCommandLine;

    void OnCommandKeydown(KeyboardEventArgs args)
    {
        if (args.Key == "Enter")
        {
            RunCommand();
        }
        else if (args.Key == "ArrowUp")
        {
            var result = StaticUtils.GetPreCommand(UniqueId, ref currentCommandLine);
            if (result.Successful)
            {
                Command = result.CommandStr;
            }
        }
        else if (args.Key == "ArrowDown")
        {
            var result = StaticUtils.GetNextCommand(UniqueId, ref currentCommandLine);
            if (result.Successful)
            {
                Command = result.CommandStr;
            }
        }
    }

    int currentOutputIndex;

    async Task WriteToConsole(string messageToWrite, bool addNewLine = true)
    {
        StaticUtils.AddOutputString(UniqueId, addNewLine ? (Constants.NewLineForShell + messageToWrite + Constants.NewLineForShell) : messageToWrite);

        await JSRuntime.InvokeAsync<object>("WriteToTerm", StaticUtils.GetOutputString(UniqueId, ref currentOutputIndex));
    }

    async void WriteToConsole()
    {
        await JSRuntime.InvokeAsync<object>("ClearTerm");

        currentOutputIndex = 0;

        await JSRuntime.InvokeAsync<object>("WriteToTerm", StaticUtils.GetOutputString(UniqueId, ref currentOutputIndex));
    }

    public async ValueTask DisposeAsync()
    {
        if (hubConnection != null)
        {
            try
            {
                await hubConnection.DisposeAsync();
            }
            catch { }
        }
    }
}